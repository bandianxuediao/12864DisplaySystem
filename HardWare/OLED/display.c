#include "includes.h"

INPUT_DATA input_data;

//==================================================================================================
//| 函数名称 | format_string_h
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 格式化显示输出的数据 
//|          | 在(x0,y0,x0+length)指定的线性区域内，字符按指定的对齐方式显示    
//|----------|--------------------------------------------------------------------------------------
//| 调用模块 | oled_print：字符输出函数
//|          |  
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | align字符相对于边框的对齐方式:左，ALIGN_LEFT； 
//|          |     							 中，ALIGN_CENTER；
//|          |     							 右，ALIGN_RIGHT
//|          | (x0,y0),字符所在区域开始的位置，    
//|          | length字符所在区域的长度    
//|          | *str：要显示的字符
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 
//|----------|--------------------------------------------------------------------------------------       
//| 全局变量 |  
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | 编写人：     时间：   
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   |      
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void format_string_h(unsigned char *str, unsigned char align, unsigned char x0,unsigned char y0, unsigned char length)
{
	unsigned char temp;

	switch (align)
	{
		case ALIGN_LEFT :					//居左
			oled_print(x0, y0, str);		//字符输出
			break;
		case ALIGN_CENTER :					//居中
			temp = (unsigned char)strlen((const char*)str)*LWIDTH;	//计算字符所占据的OLED屏的像素
			if (length > temp)
			{
				temp = (length - temp)>>1;
			}
			else
			{
				temp = 0;
			}
			oled_print(x0 + temp, y0, str);	//字符输出
			break;
		case ALIGN_RIGHT :					//居右
			temp = (unsigned char)strlen((const char*)str)*LWIDTH;	//计算字符所占据的OLED屏的像素
			if( length > temp)
			{
				temp = length - temp;
			}
			else
			{
				temp = 0;
			}
			oled_print(x0 + temp, y0, str);	//字符输出
			break;
		default :
			break;
	}
}

//==================================================================================================
//| 函数名称 | show_right_button
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 显示右功能 
//|----------|--------------------------------------------------------------------------------------
//| 调用模块 | format_string_h：格式化显示输出的数据  
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | *msg-需要显示的字符 
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 
//|----------|--------------------------------------------------------------------------------------       
//| 全局变量 |  
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | 编写人：     时间：   
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   |      
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void show_right_button(unsigned char *msg)
{
	format_string_h(msg, ALIGN_RIGHT, 0, LINE4, 128);
}

//==================================================================================================
//| 函数名称 | show_left_button
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 显示左功能 
//|----------|--------------------------------------------------------------------------------------
//| 调用模块 | format_string_h：格式化显示输出的数据  
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | *msg-需要显示的字符 
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 
//|----------|--------------------------------------------------------------------------------------       
//| 全局变量 |  
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | 编写人：     时间：   
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   |      
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void show_left_button(unsigned char *msg)
{
	format_string_h(msg, ALIGN_LEFT, 0, LINE4, 128);
}

//==================================================================================================
//| 函数名称 | show_title
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 显示标题 
//|----------|--------------------------------------------------------------------------------------
//| 调用模块 | format_string_h：格式化显示输出的数据  
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | *title-需要显示的字符 
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 
//|----------|--------------------------------------------------------------------------------------       
//| 全局变量 |  
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | 编写人：     时间：   
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   |      
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void show_title(unsigned char *title)
{
	format_string_h(title, ALIGN_CENTER, 0, LINE0, 128);
}
//==================================================================================================
//| 函数名称 | show_status_bar
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 在显示屏底部显示状态信息
//|----------|--------------------------------------------------------------------------------------
//| 调用模块 | oled_hline: 在OLED显示屏上绘制一条亮/暗的横线 
//|          | oled_rline: 在显示屏上显示一条亮/暗的竖线
//|          | format_string_h：格式化显示输出的数据 
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | *str1需要显示的字符1，align1字符1相对于边框的对齐方式
//|          | *str2需要显示的字符2，align2字符2相对于边框的对齐方式
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 
//|----------|--------------------------------------------------------------------------------------       
//| 全局变量 |  
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | 编写人：     时间：   
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 底部边框内显示内容     
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void show_status_bar(unsigned char *str1, unsigned char align1,unsigned char *str2, unsigned char align2)
{
	//显示框
	oled_hline(24,LINE4-1,102,1);				//在OLED显示屏上绘制一条亮/暗的横线
	oled_rline(24,LINE4-1,LINE4+CHEIGHT-1,1);	//在显示屏上显示一条亮/暗的竖线
	oled_rline(102,LINE4-1,LINE4+CHEIGHT-1,1);

	//把字符输入到显示框中
	if (*str1 != '\0')
	{
		format_string_h(str1, align1, 27, LINE4, 74);
	}
	if (*str2 != '\0')
	{
		format_string_h(str2, align2, 27, LINE4, 74);
	}
}

//==================================================================================================
//| 函数名称 | input_rect
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 画一个空心矩形区域 
//|----------|--------------------------------------------------------------------------------------
//| 调用模块 | oled_hline: 在OLED显示屏上绘制一条亮/暗的横线 
//|          | oled_rline: 在显示屏上显示一条亮/暗的竖线
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | (x0,y0)-矩形对角第一点 
//|          | (x1,y1)-矩形对角第二点  
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 
//|----------|--------------------------------------------------------------------------------------       
//| 全局变量 |  
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | 编写人：     时间：   
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   |      
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void input_rect(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1)
{
	oled_hline(x0,y0,x1,1);		//在OLED显示屏上绘制一条亮/暗的横线
	oled_hline(x0,y1,x1,1);		//在OLED显示屏上绘制一条亮/暗的横线
	oled_rline(x0,y0,y1,1);		//在显示屏上显示一条亮/暗的竖线
	oled_rline(x1,y0,y1,1);		//在显示屏上显示一条亮/暗的竖线
}

//==================================================================================================
//| 函数名称 | ShowCursor
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 显示光标 
//|----------|--------------------------------------------------------------------------------------
//| 调用模块 | oled_rectanglefill：在显示屏上绘制一个实心矩形框 
//|          | oled_updatescr：屏幕刷新 
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | flash：指示画亮的还是画暗的 （1-亮，0-暗）
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 
//|----------|--------------------------------------------------------------------------------------       
//| 全局变量 | cursor:光标坐标值
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | 编写人：     时间：   
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   |      
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void ShowCursor(unsigned char flash)
{
	u8 num;
	
	num = GetCurrentInputAreaNum()*LWIDTH ;//根据当前已输入字符数自动移动光标

	oled_rectanglefill(num + input_data.area_pos[input_data.area_current].x, 
		input_data.area_pos[input_data.area_current].y+1, 
		num + input_data.area_pos[input_data.area_current].x+CURSOR_WIDTH,
		input_data.area_pos[input_data.area_current].y+1+CURSOR_HEIGHT, flash?1:0);//在显示屏上绘制一个实心矩形框
	oled_updatescr(input_data.area_pos[input_data.area_current].y+1, 10);//屏幕刷新
}

//==================================================================================================
//| 函数名称 | FlashCursor 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 光标事件处理（实现光标的闪烁)
//|----------|--------------------------------------------------------------------------------------
//| 调用模块 | show_cursor：在OLED显示屏上显示一个光标 
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 |  
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 |  
//|----------|--------------------------------------------------------------------------------------       
//| 全局变量 |  
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | 编写人：     时间：   
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   |      
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void FlashCursor(void)
{
	static u8 flash = 0; //光标的亮暗标识

	flash = !flash;       //光标状态取反
	ShowCursor(flash);   //显示光标
}

//==================================================================================================
//| 函数名称 | InputDataInit 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 初始化数据数据内容
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | input1_length 输入区1最大字符数
//|          | input2_length 输入区2最大字符数
//|          | input3_length 输入区3最大字符数
//|          | input4_length 输入区4最大字符数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void InputDataInit(u8 input1_length, u8 input2_length,u8 input3_length,u8 input4_length)
{
	memset((u8*)&input_data, 0, sizeof(INPUT_DATA));
	input_data.length[0] = input1_length;
	input_data.length[1] = input2_length;	
	input_data.length[2] = input3_length;
	input_data.length[3] = input4_length;	
}

//==================================================================================================
//| 函数名称 | InputAreaNext 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 进入下一个输入区域
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void InputAreaNext(void)
{	
	if(input_data.area_current < (input_data.area_num-1))
	{
		ShowCursor(0);
		input_data.area_current++;		
	}
}

//==================================================================================================
//| 函数名称 | InputAreaBack 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 返回上一个输入区域
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void InputAreaBack(void)
{
	if(input_data.area_current>0)
	{
		ShowCursor(0);
		input_data.area_current--;
	}
}

//==================================================================================================
//| 函数名称 | AddCurrentInputData 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 保存输入数据到相应缓冲区中并显示
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | inputdata  要保存的数据指针
//|          | length    要保存的数据长度
//|          | show_type 显示方式(0为明文，其他为掩码)
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void AddCurrentInputData(u8* inputdata, u8 length, u8 show_type)
{
	u8 i,num=0;
	u8 temp[INPUT_DATA_MAX_LENGTH+1];
	
	for(i=0; i<INPUT_DATA_MAX_LENGTH; i++)
	{
		if(i<input_data.length[input_data.area_current])
		{
			if(input_data.buffer[input_data.area_current][i] == 0x00)
			{
				if(num<length)
				{
					input_data.buffer[input_data.area_current][i] = *(inputdata+num++);
				}
				else
				{
					break;
				}
			}
		}
		else
		{
			break;
		}
	}
	input_data.buffer[input_data.area_current][i] = '\0';
	if(0 == show_type)
	{//明文显示
		oled_print(input_data.area_pos[input_data.area_current].x, input_data.area_pos[input_data.area_current].y, &input_data.buffer[input_data.area_current][0]);
	}
	else
	{//掩码显示
		memset(temp, '*', input_data.length[input_data.area_current]);
		temp[GetCurrentInputAreaNum()] = '\0';
		oled_print(input_data.area_pos[input_data.area_current].x, input_data.area_pos[input_data.area_current].y, &temp[0]);		
	}
	
	oled_updatescr(input_data.area_pos[input_data.area_current].y, 12);//屏幕刷新
}

//==================================================================================================
//| 函数名称 | GetCurrentInputAreaNum 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 获取当前输入区域已输入的字符数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 当前输入区域已输入的字符数
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 GetCurrentInputAreaNum(void)
{
	u8 i;
	
	for(i=0; i<INPUT_DATA_MAX_LENGTH; i++)
	{
		if(input_data.buffer[input_data.area_current][i] == 0x00)
		{
			break;;
		}
	}
	return i;
}

//==================================================================================================
//| 函数名称 | GetCurrentInputAreaValue 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 获取当前输入区域已输入的数值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 当前输入区域已输入的数值
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u32 GetCurrentInputAreaValue(void)
{
	u32 temp = 0;
	
	if(GetCurrentInputAreaNum() > 0)
	{
		sscanf((const char*)&input_data.buffer[input_data.area_current], "%ld", &temp);
	}
	return temp;
}

//==================================================================================================
//| 函数名称 | GetCurrentInputAreaString 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 获取当前输入区域已输入的字符串
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 当前输入区域已输入的字符串指针
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8* GetCurrentInputAreaString(void)
{
	return (u8*)&input_data.buffer[input_data.area_current][0];
}

//==================================================================================================
//| 函数名称 | DeleteCurrentInputData 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 根据输入参数删除当前输入区域最后输入的字符
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | length    删除字符数
//|          | show_type 显示方式(0为明文，其他为掩码)
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | SUCCESS  删除完成  ERROR 输入区域中数据不足，删除失败
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
ErrorStatus DeleteCurrentInputData(u8 length, u8 show_type)
{
	u8 index = 0;
	u8 temp[INPUT_DATA_MAX_LENGTH+1];
	
	index = strlen((char*)&input_data.buffer[input_data.area_current]);//获取当前已输入的字符串长度
	if(index >= length)
	{
		ShowCursor(0);//先清光标
		while(length--)
		{
			input_data.buffer[input_data.area_current][--index] = '\0';
		}
		memset(temp, ' ', input_data.length[input_data.area_current]);//把最多可允许输入字符全替换为空格
		temp[input_data.length[input_data.area_current]] = '\0';
		oled_print(input_data.area_pos[input_data.area_current].x, input_data.area_pos[input_data.area_current].y, &temp[0]);
		if(0 == show_type)
		{//明文显示
			oled_print(input_data.area_pos[input_data.area_current].x, input_data.area_pos[input_data.area_current].y, &input_data.buffer[input_data.area_current][0]);
		}
		else
		{//掩码显示
			memset(temp, '*', input_data.length[input_data.area_current]);
			temp[GetCurrentInputAreaNum()] = '\0';
			oled_print(input_data.area_pos[input_data.area_current].x, input_data.area_pos[input_data.area_current].y, &temp[0]);
		}

		oled_updatescr(input_data.area_pos[input_data.area_current].y, 12);//屏幕刷新
		
		return SUCCESS;
	}
	return ERROR;
}

//==================================================================================================
//| 函数名称 | show_input_area
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 在指定位置显示输入框 
//|          | 调用输入框，同时也就决定了光标的位置，由数组input_area_pos_array记录   
//|----------|--------------------------------------------------------------------------------------
//| 调用模块 | oled_rectangle：在显示屏上绘制一个空心矩形框
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | *label输入框的标号
//|          | (x0,y0)标签的开始的地址
//|          | length输入框的长度
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 
//|----------|--------------------------------------------------------------------------------------       
//| 全局变量 | input_area_pos_array：记录光标位置坐标 
//|          | input_area_num：记录输入区域数量 
//|          | input_area_current：正在编辑的输入区位置
//|----------|-------------------------------------------------------------------------------------- 
//| 函数设计 | 编写人：     时间：   
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   |      
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void show_input_area(unsigned char *label,unsigned char x0,unsigned char y0,unsigned char length)
{
	unsigned char  slen;		//字符长度
	unsigned char  rect_x0;	//输入字符横向结束坐标
	unsigned char  rect_x1;	//输入矩形框的横向结束坐标

	slen = (unsigned char)strlen((const char *)label);	//字符的长度
	rect_x0 = x0+(slen+1)*LWIDTH;			//计算结束坐标
	if (rect_x0 > OLED_X_MAX-1)		//判断是否超出OLED限制
	{
		rect_x0 = 0;
	}

	rect_x1 = length + rect_x0;		//计算矩形框的结束坐标
	if (rect_x1 > OLED_X_MAX-1)		//判断是否超出OLED限制
	{
		rect_x1 = OLED_X_MAX - 1;
	}

	oled_rectangle(rect_x0, y0-1, rect_x1, y0 + CHEIGHT, 1);	//在显示屏上绘制一个空心矩形框
	oled_print(x0,y0,label);									//字符输出

	//记录光标显示位置	
	input_data.area_pos[input_data.area_num].x = rect_x0 + 2;
	input_data.area_pos[input_data.area_num].y = y0;
	input_data.area_num++;//记录输入区域数量
	input_data.area_current = 0;
}

//==================================================================================================
//| 函数名称 | RestoreBackupDisplay 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 恢复备份的界面
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void RestoreBackupDisplay(void)
{
	memcpy(oled_disp_buf, oled_disp_buf_pre, oled_disp_length);    //恢复上一次保存的显示缓存
	oled_updatescr(0, 64);//屏幕刷新
}


//==================================================================================================
//| 函数名称 | BackupDisplay 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 备份的界面
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void BackupCurrentDisplay(void)
{
	memcpy(oled_disp_buf_pre, oled_disp_buf, oled_disp_length);//备份OLED显存
}


//==================================================================================================
//| 函数名称 | ShowMainMenu 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 显示主菜单
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void ShowMainMenu(void)
{
	clr_disp_mem();         //清除显存数据
//		show_title("功能菜单"); //显示标题

		oled_print(0, LINE0, "1.储物柜2.李亚东") ;  //字符输出函数
//		oled_print(0, LINE2, "2.快速测试 5.延期修改") ;  //字符输出函数
//		oled_print(0, LINE3, "3.完全测试 6.系统设置") ;  //字符输出函数

//		show_right_button("列表");//显示右功能
//		show_left_button("查看"); //显示左功能

	oled_updatescr(0, 64);	   //屏幕刷新
}
//==================================================================================================
//| 函数名称 | ShowProgress 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 显示进度条
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | label 进度条标签，1为"网路初始化中..."
//|          | state 为进度条格数控制，0时清进度条，其他值时进度条按当前递增
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 当当前进度条格数(0-9)
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
//u8 ShowProgress(u8 label,u8 state)
//{
//	u8 i;
//	static u8 step = 0;
//	
//	clr_disp_mem();       //清除显存数据

//	switch(label)
//	{
//		case 1:
//				oled_print(STEP_SX, LINE1, "网路初始化中...");
//			break;
//		case 2:
//				oled_print(STEP_SX, LINE1, "快速测试中....");
//			break;
//		case 3:
//			

//				oled_print(STEP_SX, LINE1, "完全测试中....");
//				show_left_button("取消");//显示左功能
//			break;	
//		case 4:
//				show_title("设备充电");//显示标题
//			ShowBatteryVoltage();
//			break;
//		default:
//			break;
//	}

//	if(state == 0)
//	{
//		step = 0;
//	}
//	else
//	{
//		step++;
//			
//	}
//	step = step % 10;
//	for(i=0;i<=step;i++)
//	{
//		oled_print(STEP_SX+2+i*8, STEP_SY+2, "┃");//绘制进度条
//	}
//	oled_rectangle(STEP_SX, STEP_SY, STEP_SX+85, STEP_SY+15, 1);//在显示屏上绘制一个空心矩形框	
//	oled_updatescr(0, 64);//屏幕刷新
//	return step ;
//}





//==================================================================================================
//| 函数名称 | ShowDelayModifyState 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 显示延期修改状态
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void ShowDelayModifyState(u8 state)
{
	/***清除显存数据放到分支处理，因为个别分支不需要清除***/
	switch(state)
	{
		case 0:
			clr_disp_mem();//清除显存数据
			InputDataInit(3, 3, 3, 0);

				show_input_area("起始雷管",18,LINE0+4,107-69);//在指定位置显示输入框
				show_input_area("截止雷管",18,LINE0+19,107-69);//在指定位置显示输入框
				show_input_area("孔内雷管",18,LINE0+34,107-69);//在指定位置显示输入框
				show_status_bar("按L确认",ALIGN_CENTER,"",ALIGN_LEFT);//在显示屏底部显示状态信息

				show_left_button("返回");//显示左功能
				show_right_button("回删");//显示右功能				

		oled_rectangle(CONTENT_RECT3_X0,CONTENT_RECT3_Y0,CONTENT_RECT3_X1,CONTENT_RECT3_Y1,1);//在显示屏上绘制一个空心矩形框			
			break;
		case 1:
			clr_disp_mem();//清除显存数据
			InputDataInit(5, 5, 5, 0);
				show_input_area("起始延期",18,LINE0+4,107-69);//在指定位置显示输入框
				show_input_area("孔间延期",18,LINE0+19,107-69);//在指定位置显示输入框
				show_input_area("孔内延期",18,LINE0+34,107-69);//在指定位置显示输入框
				show_status_bar("按L确认",ALIGN_CENTER,"",ALIGN_LEFT);//在显示屏底部显示状态信息

				show_left_button("返回");//显示左功能
				show_right_button("回删");//显示右功能						

				oled_rectangle(CONTENT_RECT3_X0,CONTENT_RECT3_Y0,CONTENT_RECT3_X1,CONTENT_RECT3_Y1,1);//在显示屏上绘制一个空心矩形框
			break;
		default:
			break;
	}
	oled_updatescr(0, 64);//屏幕刷新	
}

//==================================================================================================
//| 函数名称 | ShowNetListInfo 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 根据输入参数显示网络列表信息
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | hole_index 起始显示的索引号，type 1 右键显示继续，其他值不显示
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：     时间：  
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
//void ShowNetListInfo(u16 hole_index, u8 type)
//{
//	unsigned char i;
//	DET_INFO *hole;
//	u8 temp[50];

//	if(DET_MAX_SIZE <= 3)
//	{
//		hole_index = 0;
//	}
//	clr_disp_mem();//清除显存数据
//	if((device_info.config1&DEV_CONFIG_LANGUAGE_MASK) == DEV_CONFIG_CHINESE)
//	{
//		oled_print(5, LINE0, "序号 |  延期  | 注册");//字符输出
//	}
//	else if((device_info.config1&DEV_CONFIG_LANGUAGE_MASK) == DEV_CONFIG_ENGLISH)
//	{				
//		oled_print(5, LINE0, " NO. | Delay  | Log");//字符输出
//	}

//	oled_hline(0, 12, 127, 1);//在OLED显示屏上绘制一条亮/暗的横线
//	for(i = 0; i < 3; i++)
//	{
//		if(hole_index >= DET_MAX_SIZE)	//判断孔号索引是否超出范围
//		{
//			if(DET_MAX_SIZE >= 3)
//			{
//				hole_index = 0;
//			}
//			else
//			{
//				break ;			
//			}
//		}
//		hole = &det_info[hole_index];
//		sprintf((char*)temp,"%c%03d |  %-5d |",device_info.name, hole_index+1, hole->delay);
//		if((hole->Serl_1 == 0x00) && (hole->Serl_2 == 0x00))	//雷管状态
//		{
//			sprintf((char*)temp+15, "  ×");
//		}
//		else
//		{
//			sprintf((char*)temp+15, "  √");
//		}		 			   
//		oled_print(5, 13+i*12, &temp[0]);//字符输出
//		hole_index++;
//	}
//	oled_hline(0, 13+i*12, 127, 1);//在OLED显示屏上绘制一条亮/暗的横线

//	if((device_info.config1&DEV_CONFIG_LANGUAGE_MASK) == DEV_CONFIG_CHINESE)
//	{
//		show_status_bar("按↑↓翻页",ALIGN_CENTER,"",ALIGN_LEFT);	 //在显示屏底部显示状态信息

//		if(1 == type)
//		{
//			show_right_button("继续");//显示右功能
//		}
//		show_left_button("返回");//显示左功能
//	}
//	else if((device_info.config1&DEV_CONFIG_LANGUAGE_MASK) == DEV_CONFIG_ENGLISH)
//	{				
//		show_status_bar("Press↑↓",ALIGN_CENTER,"",ALIGN_LEFT);	 //在显示屏底部显示状态信息

//		if(1 == type)
//		{
//			show_right_button("Go");//显示右功能
//		}
//		show_left_button("Back");//显示左功能
//	}

//	oled_updatescr(0, 64);//屏幕刷新
//}

//==================================================================================================
//| 函数名称 | DebugTest 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 显示测试结果
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | errnum 错误号
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：李亚东    时间：2015-11-27 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================

void DebugTest(u8 state)
{
	clr_disp_mem();//清除显存数据
	
	oled_rectangle(CONTENT_RECT_X0,CONTENT_RECT_Y0,CONTENT_RECT_X1,CONTENT_RECT_Y1,1) ;
	switch(state)
	{
		case 0:
//			oled_print(RECT_SL_X(10), RECT_DL0_Y, "密钥验证中");
//			oled_print(RECT_SL_X(9), RECT_DL1_Y,  "请稍候...");
			break;
		case 1:
			oled_print(RECT_SL_X(16), RECT_SL_Y, "密钥重试次数为0!");
			break;			
		case 2:
			oled_print(RECT_SL_X(13), RECT_SL_Y, "密钥已检测到...");
			break;			
		case 3:
			oled_print(RECT_SL_X(13), RECT_SL_Y, "开始检测密钥...");
			break;			
		case 4:
			oled_print(RECT_SL_X(13), RECT_SL_Y, "未检测到密钥...");
			break;			
		case 5:
			oled_print(RECT_SL_X(11), RECT_SL_Y, "出现错误...");
			break;			
		case 6:
			oled_print(RECT_SL_X(11), RECT_SL_Y, "枚举成功...");
			break;			
		case 7:
			oled_print(RECT_SL_X(13), RECT_SL_Y, "从机设备插入...");
			break;			
		case 8:
			oled_print(RECT_SL_X(13), RECT_SL_Y, "设备未连接...");
			break;					
		default:
			break;
	}
	oled_updatescr(0, 64);//屏幕刷新		
}

void Dis_menu(void)
{
    write_com(0x30);
    clrscreen();
//	clr_disp_mem();//清除显存数据

    write_com(0x80 + FIRST_ADDR);
    hzkdis("1 存包    2 取包");
    write_com(0x90 + FIRST_ADDR);
    hzkdis("3 状态    4 管理");
    write_com(0x88 + FIRST_ADDR);
    hzkdis("5 查看    6 列表");
    write_com(0x98 + FIRST_ADDR);
    hzkdis("返回        确认");
//    write_com(0xb3 + FIRST_ADDR);
//    hzkdis("登鹳雀楼");
//    write_com(0xaa + FIRST_ADDR);
//    hzkdis("( 唐 )王之焕");
}



